
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scan_dimreduction.nipalsPCA &#8212; scan_dimreduction 0.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">scan_dimreduction 0.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">scan_dimreduction.nipalsPCA</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for scan_dimreduction.nipalsPCA</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Code for calculating the PCA Loadings and Scores using NIPALS algorithm.</span>

<span class="sd">One of the most concise definitions can be found in this paper on page 7:</span>
<span class="sd">    Geladi, P.; Kowalski, B. R. Partial Least-Squares Regression: A Tutorial.</span>
<span class="sd">    Analytica Chimica Acta 1986, 185, 1â€“17.</span>
<span class="sd">    https://doi.org/10.1016/0003-2670(86)80028-9.</span>

<span class="sd">For the transformation part also see:</span>
<span class="sd">    Nelson, P. R. C.; Taylor, P. A.; MacGregor, J. F. Missing data methods</span>
<span class="sd">    in PCA and PLS: Score calculations with incomplete observations.</span>
<span class="sd">    Chemometrics and Intelligent Laboratory Systems 1996, 35(1), 45-65.</span>

<span class="sd">(c) 2020-2021: Ryan Wall (lead), David Ochsenbein</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">annotations</span><span class="p">,</span>
<span class="p">)</span>  <span class="c1"># needed so we can return NipalsPCA class in our type hints</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition._base</span> <span class="kn">import</span> <span class="n">_BasePCA</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">f</span> <span class="k">as</span> <span class="n">F_dist</span>
<span class="kn">from</span> <span class="nn">scan_dimreduction.utils</span> <span class="kn">import</span> <span class="n">_nanMult</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>


<div class="viewcode-block" id="NipalsPCA"><a class="viewcode-back" href="../../api/scan_dimreduction.html#scan_dimreduction.nipalsPCA.NipalsPCA">[docs]</a><span class="k">class</span> <span class="nc">NipalsPCA</span><span class="p">(</span><span class="n">_BasePCA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The custom-built class to use PCA using the NIPALS algorithm, i.e.,</span>
<span class="sd">    the same algorithm used in SIMCA.</span>

<span class="sd">    Attributes:</span>
<span class="sd">    ----------</span>
<span class="sd">    n_components : int</span>
<span class="sd">        The number of principal components.</span>
<span class="sd">    maxIter : int</span>
<span class="sd">        The max number of iterations for the fitting step.</span>
<span class="sd">    tolCriteria : float</span>
<span class="sd">        The convergence tolerance criterion.</span>
<span class="sd">    loadings : bool</span>
<span class="sd">        The loadings vectors of the PCA model.</span>
<span class="sd">    fitScores : np.ndarray</span>
<span class="sd">        The fitted scores of the PCA model.</span>
<span class="sd">    fitData : np.ndarray</span>
<span class="sd">        The data used to fit the model.</span>
<span class="sd">    meanCentered  : bool</span>
<span class="sd">        Whether or not the original data is mean-centered.</span>
<span class="sd">    currentLVs : int:</span>
<span class="sd">        The number of current LVs in the model (0 if not fitted yet.)</span>

<span class="sd">    Methods:</span>
<span class="sd">    ----------</span>
<span class="sd">    transform</span>
<span class="sd">        Transform input data to scores.</span>
<span class="sd">    fit</span>
<span class="sd">        Fit PCA model on input data.</span>
<span class="sd">    fit_transform</span>
<span class="sd">        Fit PCA model on input data, then transform said data to scores.</span>
<span class="sd">    inverse_transform</span>
<span class="sd">        Obtain approximation of input data given fitted model and scores.</span>
<span class="sd">    calcIMD</span>
<span class="sd">        Calculate within-model distance.</span>
<span class="sd">    calcOOMD</span>
<span class="sd">        Calculate out-of-model distance.</span>
<span class="sd">    calcLimit</span>
<span class="sd">        Calculate suitable distance threshold given fitted data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">maxIter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
        <span class="n">tolCriteria</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span>
        <span class="n">meanCentered</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The constructor for the NipalsPCA class.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_components (int, optional): The number of principle components.</span>
<span class="sd">                Defaults to 2.</span>
<span class="sd">            maxIter (int, optional): The maximum number of iterations until</span>
<span class="sd">                convergence. Defaults to 10000.</span>
<span class="sd">            tolCriteria (float, optional): The convergence threshold.</span>
<span class="sd">                Defaults to 10**-8.</span>
<span class="sd">            meanCentered (bool, optional): Whether or not the data is already</span>
<span class="sd">                mean-centered. Defaults to True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># constructor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="n">n_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">=</span> <span class="n">maxIter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolCriteria</span> <span class="o">=</span> <span class="n">tolCriteria</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">loadings</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># m x numLVs matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitScores</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># n x numLVs matrix</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fitData</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># n x m training data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meanCentered</span> <span class="o">=</span> <span class="n">meanCentered</span>

        <span class="c1"># self.fitQRes = None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">currentLVs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get current # of LVs in model.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadings</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_addComponents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_add</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for adding components to an already-constructed</span>
<span class="sd">        model.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_add (int): number of components to add</span>
<span class="sd">            verbose (bool): Whether or not to print out additional</span>
<span class="sd">                convergence information. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitData</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">currentLVs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentLVs</span>
        <span class="c1"># if model is not fitted yet, this is the default</span>
        <span class="k">if</span> <span class="n">currentLVs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Range of components to add</span>
            <span class="n">numLVs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_add</span><span class="p">)</span>

            <span class="c1"># Preallocate Scores and loadings array</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n_add</span><span class="p">))</span>
            <span class="n">loadings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n_add</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># There are loadings, so must deflate</span>
            <span class="n">simData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">simData</span>

            <span class="c1"># Range of LVs to add</span>
            <span class="n">numLVs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">currentLVs</span><span class="p">,</span> <span class="n">currentLVs</span> <span class="o">+</span> <span class="n">n_add</span><span class="p">)</span>

            <span class="c1"># Preallocate empty columns in scores/loadings</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitScores</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n_add</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">loadings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loadings</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n_add</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Scores and Loads preallocated&quot;</span><span class="p">)</span>

        <span class="c1"># Logical mask of Nan Data</span>
        <span class="n">nanMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">nanFlag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nanMask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NanMask Generated&quot;</span><span class="p">)</span>

        <span class="c1"># Loop for all LVs</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numLVs</span><span class="p">:</span>
            <span class="c1"># choose a column of inputArray</span>
            <span class="n">t_new</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># Replace any nans w/ zero</span>
            <span class="n">t_new</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">t_new</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Score initialized&quot;</span><span class="p">)</span>

            <span class="c1"># Allocate variable for a convergence test</span>
            <span class="c1"># Some weirdness w/ tables</span>
            <span class="n">convTest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># why not a scalar? - DRO</span>

            <span class="c1"># Allocate the interation counter</span>
            <span class="n">numIter</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Loop until Converged</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">convTest</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolCriteria</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">numIter</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LV </span><span class="si">{}</span><span class="s2"> Iteration </span><span class="si">{}</span><span class="s2"> Started&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">numIter</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     Conv Test is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">convTest</span><span class="p">))</span>
                <span class="c1"># Update t_old</span>
                <span class="n">t_old</span> <span class="o">=</span> <span class="n">t_new</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="n">loadings_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="c1"># Calculate the loadings vector</span>

                <span class="k">if</span> <span class="n">nanFlag</span><span class="p">:</span>
                    <span class="n">loadings_loc</span> <span class="o">=</span> <span class="n">_nanMult</span><span class="p">(</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">t_old</span><span class="p">,</span> <span class="n">nanMask</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">useDenom</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>

                    <span class="c1"># Normalize the loading</span>
                    <span class="n">loadings_loc</span> <span class="o">=</span> <span class="n">loadings_loc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="n">loadings_loc</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">loadings_loc</span>
                    <span class="p">)</span>

                    <span class="c1"># Now we compute the scores!</span>
                    <span class="n">t_new</span> <span class="o">=</span> <span class="n">_nanMult</span><span class="p">(</span>
                        <span class="n">data</span><span class="p">,</span> <span class="n">loadings_loc</span><span class="p">,</span> <span class="n">nanMask</span><span class="p">,</span> <span class="n">useDenom</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">loadings_loc</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">t_old</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">t_old</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">t_old</span><span class="p">)</span>
                    <span class="n">loadings_loc</span> <span class="o">=</span> <span class="n">loadings_loc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="n">loadings_loc</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">loadings_loc</span>
                    <span class="p">)</span>
                    <span class="n">t_new</span> <span class="o">=</span> <span class="n">data</span> <span class="o">@</span> <span class="n">loadings_loc</span>
                    <span class="n">t_new</span> <span class="o">=</span> <span class="n">t_new</span> <span class="o">/</span> <span class="p">(</span><span class="n">loadings_loc</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">loadings_loc</span><span class="p">)</span>

                <span class="c1"># Perform the convergence test</span>
                <span class="n">scoreDiff</span> <span class="o">=</span> <span class="n">t_old</span> <span class="o">-</span> <span class="n">t_new</span>
                <span class="n">convTest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">scoreDiff</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">scoreDiff</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="n">t_new</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">t_new</span>
                <span class="p">)</span>

                <span class="c1"># Increase numIter</span>
                <span class="n">numIter</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># Store scores and loads</span>
                <span class="n">scores</span><span class="p">[:,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_new</span>
                <span class="n">loadings</span><span class="p">[:,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">loadings_loc</span>

            <span class="k">if</span> <span class="n">numIter</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;maxIter Reached on LV </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration finished on LV </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="c1"># Deflate the input matrix</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">t_new</span> <span class="o">@</span> <span class="n">loadings_loc</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deflation Complete&quot;</span><span class="p">)</span>
        <span class="c1"># Store the values in self</span>
        <span class="c1"># fitScores necessary for Hotellings T2 calc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitScores</span> <span class="o">=</span> <span class="n">scores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loadings</span> <span class="o">=</span> <span class="n">loadings</span>

<div class="viewcode-block" id="NipalsPCA.set_components"><a class="viewcode-back" href="../../api/scan_dimreduction.html#scan_dimreduction.nipalsPCA.NipalsPCA.set_components">[docs]</a>    <span class="k">def</span> <span class="nf">set_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_component</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for setting the number of components in an</span>
<span class="sd">        already-constructed model. It checks to make sure that loadings</span>
<span class="sd">        exist for all of the set components and will fit extras if not.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_component (int): the desired number of components.</span>
<span class="sd">            verbose (bool): Whether or not to print out additional</span>
<span class="sd">                convergence information. Defaults to False.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: if n_component is not an int</span>
<span class="sd">            ValueError: if n_component &lt; 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_component</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;n_component must be an integer!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n_component</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n_component must be an int &gt; 0&quot;</span><span class="p">)</span>

        <span class="n">maxFitLVs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentLVs</span>
        <span class="c1"># If desired n &lt;= max fit N, simply set the number</span>
        <span class="k">if</span> <span class="n">n_component</span> <span class="o">&lt;=</span> <span class="n">maxFitLVs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="n">n_component</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_to_add</span> <span class="o">=</span> <span class="n">n_component</span> <span class="o">-</span> <span class="n">maxFitLVs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addComponents</span><span class="p">(</span><span class="n">n_to_add</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_components</span><span class="p">(</span><span class="n">n_component</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># So methods can be chained</span></div>

<div class="viewcode-block" id="NipalsPCA.transform"><a class="viewcode-back" href="../../api/scan_dimreduction.html#scan_dimreduction.nipalsPCA.NipalsPCA.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">inputArray</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;naive&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;This function takes an input array and projects it based</span>
<span class="sd">        on a fitted model.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputArray (np.ndarray): The nxm input array in the original</span>
<span class="sd">                feature space to be projected.</span>
<span class="sd">            method (str, optional): The method to use for the projection.</span>
<span class="sd">                See reference listed in module docstring.</span>
<span class="sd">                Valid options are {&#39;naive&#39;,&#39;projection&#39;,&#39;conditionalMean&#39;}</span>
<span class="sd">                Defaults to &#39;naive&#39;.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If model has not been fit yet (no loadings).</span>
<span class="sd">            ValueError: Method &#39;conditionalMean&#39; is selected but fitData is</span>
<span class="sd">                not available.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The corresponding scores.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check for fit having been done.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentLVs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Model has not yet been fit. Consider using fit_transform.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Extract shape of inputArray</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">inputArray</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Extract variables for simplicity</span>
        <span class="n">numLVs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>
        <span class="n">loadings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadings</span>

        <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">numLVs</span><span class="p">))</span>

        <span class="n">nanMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">inputArray</span><span class="p">)</span>
        <span class="n">nanFlag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nanMask</span><span class="p">)</span>
        <span class="c1"># nanFlag = True</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">nanFlag</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;naive&quot;</span><span class="p">):</span>
            <span class="c1"># uses approach described in section 3.1 of McGregor paper (Single</span>
            <span class="c1"># component projection algorithm for missing data in PCA and PLS)</span>
            <span class="k">for</span> <span class="n">LV</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numLVs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nanFlag</span><span class="p">:</span>
                    <span class="n">scores</span><span class="p">[:,</span> <span class="p">[</span><span class="n">LV</span><span class="p">]]</span> <span class="o">=</span> <span class="n">_nanMult</span><span class="p">(</span>
                        <span class="n">inputArray</span><span class="p">,</span> <span class="n">loadings</span><span class="p">[:,</span> <span class="p">[</span><span class="n">LV</span><span class="p">]],</span> <span class="n">nanMask</span><span class="p">,</span> <span class="n">useDenom</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">scores</span><span class="p">[:,</span> <span class="p">[</span><span class="n">LV</span><span class="p">]]</span> <span class="o">=</span> <span class="n">inputArray</span> <span class="o">@</span> <span class="n">loadings</span><span class="p">[:,</span> <span class="p">[</span><span class="n">LV</span><span class="p">]]</span>
                    <span class="n">scores</span><span class="p">[:,</span> <span class="p">[</span><span class="n">LV</span><span class="p">]]</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[:,</span> <span class="p">[</span><span class="n">LV</span><span class="p">]]</span> <span class="o">/</span> <span class="p">(</span>
                        <span class="n">loadings</span><span class="p">[:,</span> <span class="p">[</span><span class="n">LV</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">loadings</span><span class="p">[:,</span> <span class="p">[</span><span class="n">LV</span><span class="p">]]</span>
                    <span class="p">)</span>
                <span class="c1"># deflate input data</span>
                <span class="n">inputArray</span> <span class="o">=</span> <span class="n">inputArray</span> <span class="o">-</span> <span class="n">scores</span><span class="p">[:,</span> <span class="p">[</span><span class="n">LV</span><span class="p">]]</span> <span class="o">@</span> <span class="n">loadings</span><span class="p">[:,</span> <span class="p">[</span><span class="n">LV</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span>

        <span class="k">elif</span> <span class="n">nanFlag</span> <span class="ow">and</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;projection&quot;</span><span class="p">):</span>
            <span class="c1"># uses approach described in section 4 of McGregor paper</span>
            <span class="c1"># (Handling missing data in PCA by projection to the model plane)</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">notNull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">nanMask</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="p">:])</span>  <span class="c1"># just for readability</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span>
                    <span class="n">loadings</span><span class="p">[</span><span class="n">notNull</span><span class="p">,</span> <span class="p">:</span><span class="n">numLVs</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">loadings</span><span class="p">[</span><span class="n">notNull</span><span class="p">,</span> <span class="p">:</span><span class="n">numLVs</span><span class="p">]</span>
                <span class="p">)</span>  <span class="c1"># denominator in eq. 9</span>
                <span class="n">nom</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">loadings</span><span class="p">[</span><span class="n">notNull</span><span class="p">,</span> <span class="p">:</span><span class="n">numLVs</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">inputArray</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">notNull</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                <span class="p">)</span>  <span class="c1"># nominator in eq. 9</span>
                <span class="n">scores</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom</span> <span class="o">@</span> <span class="n">nom</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">elif</span> <span class="n">nanFlag</span> <span class="ow">and</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;conditionalMean&quot;</span><span class="p">):</span>
            <span class="c1"># uses approach described in section 5.1 of McGregor paper</span>
            <span class="c1"># (Missing data replacement using conditional mean replacement)</span>
            <span class="n">fitRows</span><span class="p">,</span> <span class="n">fitCols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitData</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitData</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;This transformation method requires calculating the&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; approximate covariance matrix on the original data.&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; This data would be stored in property &#39;fitData&#39;, but&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; is not available in this model.&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">fitCols</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">:</span>
                <span class="c1"># the number of PCs is equal to the number of variables in</span>
                <span class="c1"># the data</span>
                <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitScores</span>
                <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadings</span>
            <span class="k">elif</span> <span class="n">fitCols</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">:</span>
                <span class="n">fullModel</span> <span class="o">=</span> <span class="n">NipalsPCA</span><span class="p">(</span><span class="n">fitCols</span><span class="p">)</span>
                <span class="n">fullModel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitData</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">P</span> <span class="o">=</span> <span class="n">fullModel</span><span class="o">.</span><span class="n">loadings</span>
                <span class="n">T</span> <span class="o">=</span> <span class="n">fullModel</span><span class="o">.</span><span class="n">fitScores</span>

            <span class="n">Theta</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fitRows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">isNull</span> <span class="o">=</span> <span class="n">nanMask</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">notNull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">isNull</span><span class="p">)</span>  <span class="c1"># just for readability</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isNull</span><span class="p">):</span>
                    <span class="n">S12</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">isNull</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Theta</span> <span class="o">@</span> <span class="n">P</span><span class="p">[</span><span class="n">notNull</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">S22</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">notNull</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Theta</span> <span class="o">@</span> <span class="n">P</span><span class="p">[</span><span class="n">notNull</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>

                    <span class="c1"># compute an estimate for the missing data</span>
                    <span class="n">zHash</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">S12</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S22</span><span class="p">)</span> <span class="o">@</span> <span class="n">inputArray</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">notNull</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span>
                    <span class="n">inputArray</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">isNull</span><span class="p">]</span> <span class="o">=</span> <span class="n">zHash</span>

                <span class="n">scores</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">inputArray</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)[</span>
                    <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>
                <span class="p">]</span>

        <span class="c1"># Give the people what they want!</span>
        <span class="k">return</span> <span class="n">scores</span></div>

<div class="viewcode-block" id="NipalsPCA.fit"><a class="viewcode-back" href="../../api/scan_dimreduction.html#scan_dimreduction.nipalsPCA.NipalsPCA.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputArray</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NipalsPCA</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Fits PCA model to input data.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputArray (np.ndarray): The input data to fit on.</span>
<span class="sd">            verbose (bool, optional): Whether or not to print out additional</span>
<span class="sd">                convergence information. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            NipalsPCA: A reference to the object. Likely not needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentLVs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">BaseException</span><span class="p">(</span>
                <span class="s2">&quot;Model Object has already been fit.&quot;</span>
                <span class="o">+</span> <span class="s2">&quot; Try set_components() or build a new model object.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># n is the number of observations, m the number of variables/features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">inputArray</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_addComponents</span><span class="p">(</span><span class="n">n_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># Allows model = NipalsPCA().fit(data)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

        <span class="c1"># Not currently supporting DMODX_Norm, so no fitQRes necessary.</span>
        <span class="c1"># #Need to store the residuals for the purposes of DMODX_Norm</span>
        <span class="c1"># # At this point the inputArray is already deflated</span>
        <span class="c1"># # So one can simply calc the QRes using the inputArray directly</span>
        <span class="c1"># if verbose:</span>
        <span class="c1">#     print(&quot;OOMD Calcs Starting&quot;)</span>
        <span class="c1"># OOMD = np.zeros((n,1))</span>
        <span class="c1"># for idx in range(n):</span>
        <span class="c1">#     notNull = ~nanMask[idx,:]</span>
        <span class="c1">#     OOMD[idx,0] = (inputArray[idx,notNull] @</span>
        <span class="c1">#           inputArray[idx,notNull].T)</span>

        <span class="c1"># self.fitQRes = OOMD</span>
        <span class="c1"># if verbose:</span>
        <span class="c1">#     print(&quot;OOMD Calcs Finished&quot;)</span>

<div class="viewcode-block" id="NipalsPCA.fit_transform"><a class="viewcode-back" href="../../api/scan_dimreduction.html#scan_dimreduction.nipalsPCA.NipalsPCA.fit_transform">[docs]</a>    <span class="k">def</span> <span class="nf">fit_transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">inputArray</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Fit, then transform input data.</span>


<span class="sd">        This function is equivalent to</span>
<span class="sd">        &gt;&gt;&gt;&gt; P = NipalsPCA()</span>
<span class="sd">        &gt;&gt;&gt;&gt; P.fit(X)</span>
<span class="sd">        &gt;&gt;&gt;&gt; T = P.transform(X)</span>
<span class="sd">        Args:</span>
<span class="sd">            inputArray (np.ndarray): The The input data to fit on and</span>
<span class="sd">                to transform.</span>
<span class="sd">            verbose (bool, optional): Whether or not to print out additional</span>
<span class="sd">                convergence information. Defaults to False.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Model has already been fit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The corresponding scores.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentLVs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">inputArray</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitScores</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">scores</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Model has already been fit. Try transform instead.&quot;</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="NipalsPCA.inverse_transform"><a class="viewcode-back" href="../../api/scan_dimreduction.html#scan_dimreduction.nipalsPCA.NipalsPCA.inverse_transform">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputScores</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Approximate original data from scores.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputScores (np.ndarray): An array containing the scores.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: PCA model has not been fit yet.</span>
<span class="sd">            ValueError: Shape of provided scores does not match n_components</span>
<span class="sd">                in model.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The approximation of the original data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentLVs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Model has not yet been fit. Try fit() or fit_transform()&quot;</span>
                <span class="o">+</span> <span class="s2">&quot; instead.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Check size of inputScores:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">inputScores</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;inputScores has number of columns different than number&quot;</span>
                <span class="o">+</span> <span class="s2">&quot; of components in model&quot;</span>
            <span class="p">)</span>

        <span class="c1"># self.n_components as we may have built loadings to a larger n than</span>
        <span class="c1"># the current number of components.</span>
        <span class="n">outData</span> <span class="o">=</span> <span class="n">inputScores</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadings</span><span class="p">[:,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">outData</span></div>

<div class="viewcode-block" id="NipalsPCA.calcIMD"><a class="viewcode-back" href="../../api/scan_dimreduction.html#scan_dimreduction.nipalsPCA.NipalsPCA.calcIMD">[docs]</a>    <span class="k">def</span> <span class="nf">calcIMD</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputScores</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inputArray</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;HotellingT2&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate within-model distance.</span>

<span class="sd">        This is the distance from the</span>
<span class="sd">        center of the hyperplane to the projected observation.</span>
<span class="sd">        Args:</span>
<span class="sd">            inputScores (Optional[np.ndarray], optional): The scores from</span>
<span class="sd">                which to calculate the distance. Defaults to None.</span>
<span class="sd">            inputArray (Optional[np.ndarray], optional): The input data in</span>
<span class="sd">                original space from which to calculate the distance.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            metric (str, optional): The metric to use. Valid options are</span>
<span class="sd">                {&#39;HotellingT2&#39;}. Defaults to &#39;HotellingT2&#39;.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Model has not been fit yet.</span>
<span class="sd">            ValueError: Neither scores nor input data provided.</span>
<span class="sd">            ValueError: Input scores are inconsistent with n_components of</span>
<span class="sd">                model.</span>
<span class="sd">            ValueError: Other, unknown error with calculation of metric.</span>
<span class="sd">            NotImplementedError: Any metric that has not yet been implemented.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The calculated within-model distance for each</span>
<span class="sd">                observation (row).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Warnings if not fit</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentLVs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Model has not yet been fit. Try fit() or fit_transform()&quot;</span>
                <span class="o">+</span> <span class="s2">&quot; instead.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;HotellingT2&quot;</span><span class="p">:</span>
            <span class="c1"># Handling cases of inputArray/inputScores being present or not</span>
            <span class="c1"># No inputs = halt with value Error</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">inputArray</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">inputScores</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No values provided.&quot;</span><span class="p">)</span>

            <span class="c1"># Both inputs = warn and recalc with only one of the inputs</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">inputArray</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">inputScores</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Both Scores and Data are given. Operating on Data alone.&quot;</span>
                <span class="p">)</span>
                <span class="c1"># Call same function with only inputArray</span>
                <span class="n">outT2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcIMD</span><span class="p">(</span><span class="n">inputArray</span><span class="o">=</span><span class="n">inputArray</span><span class="p">)</span>

            <span class="k">elif</span> <span class="p">(</span><span class="n">inputScores</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">inputArray</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">inputArray</span><span class="p">)</span>
                <span class="n">outT2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcIMD</span><span class="p">(</span><span class="n">inputScores</span><span class="o">=</span><span class="n">scores</span><span class="p">)</span>

            <span class="k">elif</span> <span class="p">(</span><span class="n">inputScores</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">inputArray</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Calculate Hotelling&#39;s T2</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">numLVs</span> <span class="o">=</span> <span class="n">inputScores</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">numLVs_fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>

                <span class="k">if</span> <span class="n">numLVs</span> <span class="o">!=</span> <span class="n">numLVs_fit</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;inputScores have different number of columns/latent&quot;</span>
                        <span class="o">+</span> <span class="s2">&quot; variables than model n_components.&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outT2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

                    <span class="n">fitMeans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitScores</span><span class="p">[:,</span> <span class="p">:</span><span class="n">numLVs_fit</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">fitVars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">fitScores</span><span class="p">[:,</span> <span class="p">:</span><span class="n">numLVs_fit</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span>
                    <span class="p">)</span>
                    <span class="n">outT2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">inputScores</span> <span class="o">-</span> <span class="n">fitMeans</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">fitVars</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Unknown issue in IMD method (metric = HotellingT2) with&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; inputs.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;This metric has not been implemented. See doc.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">outT2</span></div>

<div class="viewcode-block" id="NipalsPCA.calcOOMD"><a class="viewcode-back" href="../../api/scan_dimreduction.html#scan_dimreduction.nipalsPCA.NipalsPCA.calcOOMD">[docs]</a>    <span class="k">def</span> <span class="nf">calcOOMD</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">inputArray</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;QRes&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculated the out-of-model distance (OOMD) of an observation.</span>

<span class="sd">        Args:</span>
<span class="sd">            inputArray (np.ndarray): The data for which to calculate the</span>
<span class="sd">                OOMDs.</span>
<span class="sd">            metric (str, optional): The metric to use. Valid options are</span>
<span class="sd">                {&#39;Qres&#39;,&#39;DModX&#39;} Defaults to &#39;QRes&#39;.</span>

<span class="sd">        Raises:</span>
<span class="sd">            NotImplementedError: Unknown metric.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The distances for the provided observations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;QRes&quot;</span><span class="p">:</span>
            <span class="c1"># To not perform calc on inputArray</span>
            <span class="n">transformDat</span> <span class="o">=</span> <span class="n">inputArray</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Preallocate output</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">inputArray</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">outOOMD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

            <span class="c1"># Calculate scores (transform should handle error Handling)</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">transformDat</span><span class="p">)</span>

            <span class="c1"># Calculate Fitted Data</span>
            <span class="n">modeledData</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>

            <span class="c1"># Calculate Residuals</span>
            <span class="n">resids</span> <span class="o">=</span> <span class="n">transformDat</span> <span class="o">-</span> <span class="n">modeledData</span>

            <span class="n">nanMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">resids</span><span class="p">)</span>
            <span class="n">notNull</span> <span class="o">=</span> <span class="o">~</span><span class="n">nanMask</span>
            <span class="c1"># Calculate Q_residuals as DMODX is based off of this value</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">outOOMD</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">resids</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">notNull</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="p">:]]</span>
<div class="viewcode-block" id="NipalsPCA.calcLimit"><a class="viewcode-back" href="../../api/scan_dimreduction.html#scan_dimreduction.nipalsPCA.NipalsPCA.calcLimit">[docs]</a>                    <span class="o">@</span> <span class="n">resids</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">notNull</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="p">:]]</span><span class="o">.</span><span class="n">T</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;DModX&quot;</span><span class="p">:</span>
            <span class="c1"># Pull out params for weird Simca Factor</span>
            <span class="n">fitN</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitScores</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">numLVs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>

            <span class="c1"># Calculate the QRes</span>
            <span class="n">outOOMD</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calcOOMD</span><span class="p">(</span><span class="n">inputArray</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;QRes&quot;</span><span class="p">)</span>

            <span class="c1"># A0 is 1 if mean centered.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meanCentered</span><span class="p">:</span>
                <span class="n">A0</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">A0</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">nanMask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">inputArray</span><span class="p">)</span>
            <span class="n">notNull</span> <span class="o">=</span> <span class="o">~</span><span class="n">nanMask</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">notNull</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fitN</span> <span class="o">/</span> <span class="p">((</span><span class="n">fitN</span> <span class="o">-</span> <span class="n">numLVs</span> <span class="o">-</span> <span class="n">A0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="n">numLVs</span><span class="p">)))</span>
            <span class="n">outOOMD</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">outOOMD</span><span class="p">)</span>

        <span class="c1"># This is close, but there are some issues with it. Play if you</span>
        <span class="c1"># want to develop, otherwise it stays commented out!</span>
        <span class="c1"># elif metric == &#39;DModX_Norm&#39;:</span>
        <span class="c1">#     #Pull out params</span>
        <span class="c1">#     M, _ = self.fitScores.shape</span>

        <span class="c1">#     #Calc factor and adjust outOOMD</span>
        <span class="c1">#     factor = np.sqrt(M/np.sum(self.fitQRes))</span>

        <span class="c1">#     # Out is QResiduals, square root, times a factor</span>
        <span class="c1">#     outOOMD = factor * np.sqrt(self.calcOOMD(inputArray))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Input metric not recognized. See doc.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">outOOMD</span></div>

    <span class="k">def</span> <span class="nf">calcLimit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;HotellingT2&quot;</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">numLVs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">m</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;This function calculates the limits for IMD and OOMD.</span>

<span class="sd">        Args:</span>
<span class="sd">            metric (str, optional): The metric to use. Valid options are</span>
<span class="sd">                {&#39;HotellingT2&#39;,&#39;DModX&#39;} Defaults to &#39;HotellingT2&#39;.</span>
<span class="sd">            n (Optional[int], optional): The number of observations.</span>
<span class="sd">                Defaults to None, which results in the n of the fitted scores</span>
<span class="sd">                to be used.</span>
<span class="sd">            numLVs (Optional[int], optional): The number of latent variables</span>
<span class="sd">                (principal components). Defaults to None, which results in</span>
<span class="sd">                the m of the fitted scores to be used.</span>
<span class="sd">            m (Optional[int], optional): The number of original features.</span>
<span class="sd">                Defaults to None, which results in the number of features in</span>
<span class="sd">                the original data/fitted loadings to be used.</span>
<span class="sd">            alpha (float, optional): The confidence value to use.</span>
<span class="sd">                Defaults to 0.95.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The limit threshold for the given metric and</span>
<span class="sd">                confidence value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>

        <span class="c1"># if not specified otherwise we take the values from the fitted model</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitScores</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Might be best as self.loadings.shape[0]</span>
            <span class="c1"># so one can export a &quot;minimal&quot; model (-RMW)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">numLVs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">numLVs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span>

        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;HotellingT2&quot;</span><span class="p">:</span>
            <span class="n">tsqcl</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">F_dist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">numLVs</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">numLVs</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">numLVs</span>
                <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">numLVs</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># note that the axes of the &#39;ellipsis of happiness&#39; shown in</span>
            <span class="c1"># SIMCA are calculated as</span>
            <span class="c1"># ax_i = sqrt(s_i^2 * tsqcl(0.95, 2, n-2))</span>
            <span class="c1"># where s_i is the standard deviation of score i</span>

            <span class="k">return</span> <span class="n">tsqcl</span>

        <span class="k">elif</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;DModX&quot;</span><span class="p">:</span>
            <span class="c1"># the following equation were taken from the SIMCA help doc;</span>
            <span class="c1"># their origin is not clear.</span>
            <span class="c1"># A0 is 1 if mean centered.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meanCentered</span><span class="p">:</span>
                <span class="n">A0</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">A0</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># degrees of freedom of the model</span>
            <span class="n">DF_mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">A0</span> <span class="o">-</span> <span class="n">numLVs</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">numLVs</span><span class="p">))</span>

            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">m</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">DF_mod</span><span class="p">])</span>
            <span class="n">CORR</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">A0</span> <span class="o">-</span> <span class="n">numLVs</span><span class="p">)</span>

            <span class="c1"># degrees of freedom of the observations</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">DF_mod</span><span class="p">:</span>
                <span class="n">DF_obs</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">DF_mod</span><span class="p">)</span> <span class="o">-</span> <span class="n">numLVs</span><span class="p">)</span> <span class="o">/</span> <span class="n">CORR</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">DF_obs</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">numLVs</span><span class="p">)</span> <span class="o">/</span> <span class="n">CORR</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">DF_mod</span><span class="p">,</span> <span class="n">DF_obs</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">A0</span> <span class="o">-</span> <span class="n">numLVs</span><span class="p">)])</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;One of the factors in the calculation of the DModX limits&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; was smaller than 1. This shouldn&#39;t happen.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># normalized DCrit value</span>
            <span class="n">DCrit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">F_dist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">DF_obs</span><span class="p">,</span> <span class="n">DF_mod</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">DCrit</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">scan_dimreduction 0.0.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">scan_dimreduction.nipalsPCA</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, David Ochsenbein.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.2.
    </div>
  </body>
</html>